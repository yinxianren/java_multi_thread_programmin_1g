1.方法内的变量为线程安全
   非线程安全 的问题存在于 实例变量 中，如果方法内部私有变量，则不存在 非线程安装 问题，所以得出论就是线程安全的；
2.在两个线程访问同一个对象中的同步方法时，一定是线程安全的；
3.关键字 synchronize 取得的锁都是对象锁，而不是把一段代码或者方法当作锁；
4.如果多个线程访问多个对象，则jvm会创建多个锁；
5.只有共享资源读写访问才需要同步化，如果不是共享资源，那么没不要同步；
6.synchronize方法 和 锁对象
  1.A线程先持有object对象的Lock锁，B线程可以异步的方式调用object对象中非synchronize类型的方法；
  2.A线程先持有object对象的Lock锁，B线程如果在这是调用对象中synchronize类型的方法则需要等待，也就是同步；
7.脏读
  1.如果赋值时进行同步，而取值的时候没有进行同步，那么有可能出现一些意想不到的结果，这种情况就是脏读；发生脏读的情况是在实例变量时，此时该值已经被其他线程更改过了
8.synchronize 锁重入
  1.当一个线程得到一个对象锁后，再次请求此对象时，是可以再次得到该对象锁；
  2.可重入锁  的概念是自己可以再次获取自己的内部锁；
  3.当存在父子继承关系时，子类是完全可以同过“可重入锁“ 调用父类的同步方法；
9.synchronize 锁，发生异常，锁自动释放；
10.synchronize，同步不具有继承性；
11.synchronize 关键字加到static静态方法上是给class类上加锁，而synchronize关键字加到非static静态方法上是对象上锁，
   如果同类中，存在这两种锁，则他们是异步执行的；
12.class锁，对所有对象实例都是起作用的，这个和对象锁的不同之处；
    synchronize(x.class)--->类锁，所有对象都生效；
    synchronize(this)   --->对象锁，只对同一个对象实例有效；
13.在jvm中，String具有常量缓存功能，因此synchronize代码块都不使用String作为锁对象，而改成 new Object 来代替；

14.关键字volatile的作用是强制从公共堆中取变量，而不是从线程私有数据栈取的变量的值；



